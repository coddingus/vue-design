<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>权衡的艺术 | Vue.js 设计与实现</title>
    <meta name="description" content="《Vue.js 设计与实现》笔记">
    <link rel="stylesheet" href="/vue-design/assets/style.ccfbcf6f.css">
    <link rel="modulepreload" href="/vue-design/assets/app.dab76f62.js">
    <link rel="modulepreload" href="/vue-design/assets/design_art.md.3295b3f5.lean.js">
    
    <meta name="twitter:title" content="权衡的艺术 | Vue.js 设计与实现">
  <meta property="og:title" content="权衡的艺术 | Vue.js 设计与实现">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-9d08d850><div class="sidebar-button" data-v-9d08d850><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/vue-design/" aria-label="Vue.js 设计与实现, back to home" data-v-9d08d850 data-v-3d0790b8><!----> Vue.js 设计与实现</a><div class="flex-grow" data-v-9d08d850></div><div class="nav" data-v-9d08d850><nav class="nav-links" data-v-9d08d850 data-v-242b059e><!--[--><div class="item" data-v-242b059e><div class="nav-link" data-v-242b059e data-v-3f26d8fd><a class="item" href="/vue-design/" data-v-3f26d8fd>首页 <!----></a></div></div><div class="item" data-v-242b059e><div class="nav-link" data-v-242b059e data-v-3f26d8fd><a class="item active" href="/vue-design/design/art" data-v-3f26d8fd>指南 <!----></a></div></div><div class="item" data-v-242b059e><div class="nav-link" data-v-242b059e data-v-3f26d8fd><a class="item isExternal" href="https://github.com/coddingus/vue-design" target="_blank" rel="noopener noreferrer" data-v-3f26d8fd>Github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-3f26d8fd><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-1905930f><nav class="nav-links nav" data-v-1905930f data-v-242b059e><!--[--><div class="item" data-v-242b059e><div class="nav-link" data-v-242b059e data-v-3f26d8fd><a class="item" href="/vue-design/" data-v-3f26d8fd>首页 <!----></a></div></div><div class="item" data-v-242b059e><div class="nav-link" data-v-242b059e data-v-3f26d8fd><a class="item active" href="/vue-design/design/art" data-v-3f26d8fd>指南 <!----></a></div></div><div class="item" data-v-242b059e><div class="nav-link" data-v-242b059e data-v-3f26d8fd><a class="item isExternal" href="https://github.com/coddingus/vue-design" target="_blank" rel="noopener noreferrer" data-v-3f26d8fd>Github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-3f26d8fd><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-1905930f><!--[--><li class="sidebar-link"><p class="sidebar-link-item">框架设计概览</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item active" href="/vue-design/design/art">权衡的艺术</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#命令式和声明式">命令式和声明式</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#命令式">命令式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#声明式">声明式</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#性能与可维护性的权衡">性能与可维护性的权衡</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#虚拟dom的性能到底如何">虚拟DOM的性能到底如何</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#运行时和编译时">运行时和编译时</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#纯运行时">纯运行时</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#运行时-编译时">运行时 + 编译时</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#纯编译时">纯编译时</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/design/elements">框架设计的核心要素</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/design/thinking">Vue.js 3 的设计思路</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-1a69bec7><div class="container" data-v-1a69bec7><!--[--><!--]--><div style="position:relative;" class="content" data-v-1a69bec7><div><h1 id="权衡的艺术" tabindex="-1">权衡的艺术 <a class="header-anchor" href="#权衡的艺术" aria-hidden="true">#</a></h1><h2 id="命令式和声明式" tabindex="-1">命令式和声明式 <a class="header-anchor" href="#命令式和声明式" aria-hidden="true">#</a></h2><p>视图层框架通常分为命令式和声明式</p><h3 id="命令式" tabindex="-1">命令式 <a class="header-anchor" href="#命令式" aria-hidden="true">#</a></h3><p>命令式的一大特点就是<strong>关注过程</strong>。早年间流行的 <a href="https://jquery.com/" target="_blank" rel="noopener noreferrer">jQuery</a> 就是典型的命令式框架</p><p>将下面这段话翻译成代码</p><ul><li><code>id</code> 为 <code>app</code> 的元素</li><li>把它的文本内容为 <code>hello world</code></li><li>为其绑定点击事件</li><li>点击时弹出提示: <code>ok</code></li></ul><p>使用 <code>Jquery</code> 的对应代码</p><div class="language-js"><pre><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>click<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;ok&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>下面使用原生的JavaScript代码实现同样的功能</p><div class="language-js"><pre><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>
el<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span>
el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;ok&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们可以看到，这两种方式的过程都没有什么区别，代码本身就是“做事的过程”</p><h3 id="声明式" tabindex="-1">声明式 <a class="header-anchor" href="#声明式" aria-hidden="true">#</a></h3><p>声明式框架更加<strong>关注结果</strong></p><p>使用声明式实现上面的功能</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>alert(<span class="token punctuation">&#39;</span>ok<span class="token punctuation">&#39;</span>)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面的这种写法是基于 Vue 模板实现的。 Vue.js 帮我们封装了过程，它的内部是<strong>命令式</strong>的，但暴露给我们使用的是<strong>声明式</strong>的</p><h2 id="性能与可维护性的权衡" tabindex="-1">性能与可维护性的权衡 <a class="header-anchor" href="#性能与可维护性的权衡" aria-hidden="true">#</a></h2><p>命令式和生命式各有优点，在框架设计方面，则体现在性能与可维护性的权衡。 书中直接先给了个结论， <strong>生命式代码性能不优于命令式代码的性能</strong></p><p>我们如果要修改div的内容为 <code>hello vue3</code>， 实现的代码很简单</p><div class="language-js"><pre><code>div<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">&#39;hello vue3&#39;</span>
</code></pre></div><p>有没有比这段代码更优的性能呢？ 答案是：没有。我们可以看到，命令式代码可以做到极致的性能优化，因为已经确定了哪里需要修改，直接修改就可以了</p><p>对于框架而言，为了实现最优性能，需要先寻找差异，并只更新变化的地方（比如我们使用的 Vue.js）,但是最后执行更新的肯定会执行上面的代码</p><p>声明式比命令式多了个<strong>寻找差异的过程</strong>，所以声明式代码在性能上肯定是无法超越命令式代码的</p><ul><li>命令式：更新 DOM 性能</li><li>声明式：寻找差异性能 + 更新 DOM 性能</li></ul><p>那么为什么还要使用声明式的设计方案呢？答案肯定是声明式代码的<strong>可维护性强</strong>。采用命令式代码时，我们需要维护整个过程，而声明式代码展示的就是我们想要的结果，我们不需要关心是怎么实现的。</p><p>例如我们要实现一个 DOM 元素，展示两秒后以移除元素。下面是命令式声明的写法</p><div class="language-js"><pre><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
    el<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>下面是使用声明式的代码</p><div class="language-js"><pre><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    app<span class="token punctuation">.</span>showEl <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>我们可以看到，使用声明式我们不需要关注过程，vue 内部已经帮我们封装好了（比如移除 DOM 事件、移除 DOM）</p><h2 id="虚拟dom的性能到底如何" tabindex="-1">虚拟DOM的性能到底如何 <a class="header-anchor" href="#虚拟dom的性能到底如何" aria-hidden="true">#</a></h2><p>如果能够最小化的找出寻找差异的性能消耗，那么声明式代码的性能就可以无限接近命令式代码的性能</p><p>原生的 JavaScript 实际上指的是像 <code>document.createElement</code> 之类的DOM 操作方法，并不包含 <code>innerHTML</code></p><p><code>innerHTML</code> 和 <code>document.createElement</code> 有何差异呢?</p><p>下面是一段 html 字符串</p><div class="language-js"><pre><code><span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;span&gt;...&lt;/span&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
</code></pre></div><p>给 DOM 元素添加 <code>innerHTML</code> 属性</p><div class="language-js"><pre><code>el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> html
</code></pre></div><p>这段话看上去是不是很简单？ 然而，其实并不简单。为了渲染页面，需要把字符串解析成 DOM 树，这是一个 DOM 层面的运算。我们知道，设计 DOM 的运算要<strong>远比</strong> <code>JavaScript</code> 层面的计算性能差</p><p>虚拟 <code>DOM</code> 创建页面的性能，分为两步</p><ol><li>创建 <code>JavaScript</code>对象</li><li>递归遍历这个对象并创建真实 <code>DOM</code> 元素</li></ol><p>下面比较下虚拟 <code>DOM</code> 和 <code>innerHTML</code> 在创建页面时性能</p><table><thead><tr><th></th><th>虚拟 DOM</th><th>innerHTML</th></tr></thead><tbody><tr><td>纯 <code>JavaScript</code> 运算</td><td>创建 <code>JavaScript</code>对象（VNode）</td><td>渲染 <code>innerHTML</code> 字符串</td></tr><tr><td>DOM 运算</td><td>创建所有 <code>DOM</code> 对象</td><td>新建所有 <code>DOM</code> 元素</td></tr></tbody></table><p>从上面可以看到，两者的差距不大。虚拟 <code>DOM</code> 没有任何优势，那么我们先看看页面更新时的性能比较</p><table><thead><tr><th></th><th>虚拟 DOM</th><th>innerHTML</th></tr></thead><tbody><tr><td>纯 <code>JavaScript</code> 运算</td><td>创建 新<code>JavaScript</code>对象（VNode） + 比较（Diff）</td><td>渲染 <code>innerHTML</code> 字符串</td></tr><tr><td>DOM 运算</td><td>更新必要 <code>DOM</code></td><td>删除所有 <code>DOM</code> 元素 <br> 新建所有的 <code>DOM</code></td></tr><tr><td>性能原因</td><td>与变化数量有关</td><td>与模板大小有关</td></tr></tbody></table><p>我们可以看出，虚拟 <code>DOM</code> 多了个 Diff 过程的性能消耗，但它是 JavaScript 层面的运算，所以不会产生数量级的差异。在DOM方面的运算，虚拟 DOM 只会更新必要的 DOM 元素，优势就体现出来了</p><p>命令式声明虽然性能最优，但心智负担和可维护性较差， 我们思考下如何既做到声明式描述UI，又具备原生 JavaScript 的性能呢？</p><h2 id="运行时和编译时" tabindex="-1">运行时和编译时 <a class="header-anchor" href="#运行时和编译时" aria-hidden="true">#</a></h2><p>设计一个框架时，有三种选择</p><ul><li>纯运行时</li><li>运行时 + 编译时</li><li>纯编译时</li></ul><h3 id="纯运行时" tabindex="-1">纯运行时 <a class="header-anchor" href="#纯运行时" aria-hidden="true">#</a></h3><p>假设我们设计了一个框架，提供了一个 render 函数, 会根据改对象渲染成 DOM 元素</p><div class="language-js"><pre><code><span class="token keyword">const</span> vdom <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
        <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;span&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每个对象有两个属性，tag 代码标签， children 既可以是一个数组（代表子节点），也可以是一个字符串（代表文本）</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vdom<span class="token punctuation">,</span> root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vdom<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> vdom<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vdom<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
        el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vdom<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vdom<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token function">render</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> el<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    root<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用它</p><div class="language-js"><pre><code><span class="token keyword">const</span> vdom <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
        <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;span&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token function">render</span><span class="token punctuation">(</span>vdom<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码提供的就是一个纯运行时。但这种写法它麻烦了，我们最好能提供 html 代码片段的写法。这就是我们说的 运行时 + 编译时</p><h3 id="运行时-编译时" tabindex="-1">运行时 + 编译时 <a class="header-anchor" href="#运行时-编译时" aria-hidden="true">#</a></h3><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>为了能够将上面的代码编译成下面, 我们需要实现一个编译函数</p><div class="language-js"><pre><code><span class="token keyword">const</span> vdom <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
        <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;span&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用时，只需要调用</p><div class="language-js"><pre><code><span class="token comment">// 将html模板编译成对象</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">compiler</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这样就变成了 运行时 + 编译时 ，不过上面的代码存在一定的性能开销，因为编译时代码执行后才开始编译。因此我们可以在构建的时候执行compiler编译好。等到运行时就不需要编译了</p><h3 id="纯编译时" tabindex="-1">纯编译时 <a class="header-anchor" href="#纯编译时" aria-hidden="true">#</a></h3><p>既然编译器可以把 html 字符串解析成数据对象，能不能直接编译成命令式代码呢？</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>编译成</p><div class="language-js"><pre><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> span <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;span&#39;</span><span class="token punctuation">)</span>
span<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span>
el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
</code></pre></div><p>这样就变成了纯编译时的框架，不支持任何运行时的内容，用户的代码只有编译后才能运行。这种性能会比较好，但确实了灵活性 <a href="https://www.sveltejs.cn" target="_blank" rel="noopener noreferrer">Svelte</a> 就是纯编译时的框架，但是它的真实性能可能达不到理论高度</p></div></div><footer class="page-footer" data-v-1a69bec7 data-v-599c2f45><div class="edit" data-v-599c2f45><div class="edit-link" data-v-599c2f45 data-v-a90154d0><!----></div></div><div class="updated" data-v-599c2f45><!----></div></footer><div class="next-and-prev-link" data-v-1a69bec7 data-v-8ee16908><div class="container" data-v-8ee16908><div class="prev" data-v-8ee16908><!----></div><div class="next" data-v-8ee16908><a class="link" href="/vue-design/design/elements" data-v-8ee16908><span class="text" data-v-8ee16908>框架设计的核心要素</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-8ee16908><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"design_art.md\":\"3295b3f5\",\"design_elements.md\":\"b3cbef95\",\"design_thinking.md\":\"797cbdf4\",\"index.md\":\"c91c28c2\"}")</script>
    <script type="module" async src="/vue-design/assets/app.dab76f62.js"></script>
    
  </body>
</html>