<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>非原始值的响应式方案 | Vue.js 设计与实现</title>
    <meta name="description" content="《Vue.js 设计与实现》笔记">
    <link rel="stylesheet" href="/vue-design/assets/style.2bc7ae93.css">
    <link rel="modulepreload" href="/vue-design/assets/app.148e1184.js">
    <link rel="modulepreload" href="/vue-design/assets/guide_reactivity_non-original.md.44a5ca92.lean.js">
    
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
  <meta name="twitter:title" content="非原始值的响应式方案 | Vue.js 设计与实现">
  <meta property="og:title" content="非原始值的响应式方案 | Vue.js 设计与实现">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-6812f3ed><div class="sidebar-button" data-v-6812f3ed><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/vue-design/" aria-label="Vue.js 设计与实现, back to home" data-v-6812f3ed data-v-0ff9260d><img class="logo" src="/vue-design/logo.svg" alt="Logo" data-v-0ff9260d> Vue.js 设计与实现</a><div class="flex-grow" data-v-6812f3ed></div><div class="nav" data-v-6812f3ed><nav class="nav-links" data-v-6812f3ed data-v-6b0e7b2e><!--[--><div class="item" data-v-6b0e7b2e><div class="nav-link" data-v-6b0e7b2e data-v-4f254c5c><a class="item" href="/vue-design/" data-v-4f254c5c>首页 <!----></a></div></div><div class="item" data-v-6b0e7b2e><div class="nav-link" data-v-6b0e7b2e data-v-4f254c5c><a class="item" href="/vue-design/design/art" data-v-4f254c5c>指南 <!----></a></div></div><div class="item" data-v-6b0e7b2e><div class="nav-dropdown-link" data-v-6b0e7b2e data-v-545685d7><button class="button" data-v-545685d7><span class="button-text" data-v-545685d7>相关链接</span><span class="right button-arrow" data-v-545685d7></span></button><ul class="dialog" data-v-545685d7><!--[--><li class="dialog-item" data-v-545685d7><div class="nav-dropdown-link-item" data-v-545685d7 data-v-6fb9cd60><a class="item isExternal" href="https://vuejs.org" target="_blank" rel="noopener noreferrer" data-v-6fb9cd60><span class="arrow" data-v-6fb9cd60></span><span class="text" data-v-6fb9cd60>Vue.js 文档</span><span class="icon" data-v-6fb9cd60><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-6fb9cd60><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><li class="dialog-item" data-v-545685d7><div class="nav-dropdown-link-item" data-v-545685d7 data-v-6fb9cd60><a class="item isExternal" href="https://v2.vuejs.org" target="_blank" rel="noopener noreferrer" data-v-6fb9cd60><span class="arrow" data-v-6fb9cd60></span><span class="text" data-v-6fb9cd60>Vue.js 2 文档</span><span class="icon" data-v-6fb9cd60><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-6fb9cd60><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-6b0e7b2e><div class="nav-link" data-v-6b0e7b2e data-v-4f254c5c><a class="item isExternal" href="https://github.com/coddingus/vue-design" target="_blank" rel="noopener noreferrer" data-v-4f254c5c>Github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-4f254c5c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-41228864><nav class="nav-links nav" data-v-41228864 data-v-6b0e7b2e><!--[--><div class="item" data-v-6b0e7b2e><div class="nav-link" data-v-6b0e7b2e data-v-4f254c5c><a class="item" href="/vue-design/" data-v-4f254c5c>首页 <!----></a></div></div><div class="item" data-v-6b0e7b2e><div class="nav-link" data-v-6b0e7b2e data-v-4f254c5c><a class="item" href="/vue-design/design/art" data-v-4f254c5c>指南 <!----></a></div></div><div class="item" data-v-6b0e7b2e><div class="nav-dropdown-link" data-v-6b0e7b2e data-v-545685d7><button class="button" data-v-545685d7><span class="button-text" data-v-545685d7>相关链接</span><span class="right button-arrow" data-v-545685d7></span></button><ul class="dialog" data-v-545685d7><!--[--><li class="dialog-item" data-v-545685d7><div class="nav-dropdown-link-item" data-v-545685d7 data-v-6fb9cd60><a class="item isExternal" href="https://vuejs.org" target="_blank" rel="noopener noreferrer" data-v-6fb9cd60><span class="arrow" data-v-6fb9cd60></span><span class="text" data-v-6fb9cd60>Vue.js 文档</span><span class="icon" data-v-6fb9cd60><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-6fb9cd60><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><li class="dialog-item" data-v-545685d7><div class="nav-dropdown-link-item" data-v-545685d7 data-v-6fb9cd60><a class="item isExternal" href="https://v2.vuejs.org" target="_blank" rel="noopener noreferrer" data-v-6fb9cd60><span class="arrow" data-v-6fb9cd60></span><span class="text" data-v-6fb9cd60>Vue.js 2 文档</span><span class="icon" data-v-6fb9cd60><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-6fb9cd60><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-6b0e7b2e><div class="nav-link" data-v-6b0e7b2e data-v-4f254c5c><a class="item isExternal" href="https://github.com/coddingus/vue-design" target="_blank" rel="noopener noreferrer" data-v-4f254c5c>Github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-4f254c5c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-41228864><!--[--><li class="sidebar-link"><p class="sidebar-link-item">框架设计概览</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/design/art">权衡的艺术</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/design/elements">框架设计的核心要素</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/design/thinking">Vue.js 3 的设计思路</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">响应系统</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/reactivity/function-and-realization">响应系统的作用与实现</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/vue-design/guide/reactivity/non-original">非原始值的响应式方案</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#理解-proxy-和-reflect">理解 Proxy 和 Reflect</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#proxy">Proxy</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect">Reflect</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#javascript-对象及-proxy-的工作原理">JavaScript 对象及 Proxy 的工作原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#如何代理-object">如何代理 Object</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#in-操作符拦截">in 操作符拦截</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#for-in-拦截">for...in 拦截</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#delete-拦截">delete 拦截</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#合理的触发响应">合理的触发响应</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#新旧值处理">新旧值处理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#原型继承处理">原型继承处理</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#浅响应与深响应">浅响应与深响应</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#深响应">深响应</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#浅响应">浅响应</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#只读和浅只读">只读和浅只读</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#代理数组">代理数组</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#数组的索引与-length">数组的索引与 length</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#for-in">for...in</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#for-of">for...of</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#数组的查找方法">数组的查找方法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#隐式修改数组长度的原型方法">隐式修改数组长度的原型方法</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#代理集合类型">代理集合类型</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#如何代理-set-和-map">如何代理 Set 和 Map</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#建立响应联系">建立响应联系</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/reactivity/original">原始值的响应式方案</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-0b036348><div class="container" data-v-0b036348><!--[--><!--]--><div style="position:relative;" class="content" data-v-0b036348><div><h1 id="非原始值的响应式方案" tabindex="-1">非原始值的响应式方案 <a class="header-anchor" href="#非原始值的响应式方案" aria-hidden="true">#</a></h1><p>前面介绍了响应式数据的基本原理，这节把焦点放在响应式数据本身。实现响应式数据远比我们想象的难很多，不想我们前面讲的那样。比如如何拦截 for...in 循环？ track 函数如何追踪拦截 for...in 循环？ 类似的问题还有很多。除此之外，还应考虑如何对数组进行代理，Vue.js 还支持集合类型（如 Map 、WeakMap 、 Set 、WeakSet 等），如何对集合类型进行代理。</p><p>要实现完善的响应式数据，还需要深入了解语言规范</p><h2 id="理解-proxy-和-reflect" tabindex="-1">理解 Proxy 和 Reflect <a class="header-anchor" href="#理解-proxy-和-reflect" aria-hidden="true">#</a></h2><p>Vue.js 3 的响应式数据时基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy</a> 实现的，所以有必要了解 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy</a> 以及与之关联的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener noreferrer">Reflect</a></p><p>学习 Proxy 和 Reflect 可以参考阮一峰老师的 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">《ES6 入门教程》</a>。</p><ul><li>Proxy 链接 <a href="https://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener noreferrer">https://es6.ruanyifeng.com/#docs/proxy</a></li><li>Reflect 链接 <a href="https://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener noreferrer">https://es6.ruanyifeng.com/#docs/reflect</a></li></ul><h3 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-hidden="true">#</a></h3><p>什么是 Proxy ? 简单地说，使用 Proxy 可以创建一个代理对象，它可以代理<strong>其他对象</strong>，注意的是<strong>其他对象</strong>，并且只能代理对象，无法代理对象值（例如字符串、布尔值等）。所谓代理，指的是对一个对象的<strong>基本语义</strong>的代理，它允许我们<strong>拦截</strong>并<strong>重新定义</strong>一个对象的操作</p><p>什么是基本语义？ 例如给出一个对象 obj ，可以对它进行一些操作，如读取属性值、设置属性值。类似的这种读取、设置属性值的操作就属于基本语义的操作。</p><p>使用 Proxy 拦截一个对象</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">/*拦截读取属性*/</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">/*拦截设置属性*/</span>
    <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>函数也是一个对象，所以可以也使用 Proxy 对函数简写拦截</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;我是：&#39;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> argArray</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;拦截了&#39;</span><span class="token punctuation">)</span>
        <span class="token function">target</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>argArray<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">p2</span><span class="token punctuation">(</span><span class="token string">&#39;shibin&#39;</span><span class="token punctuation">)</span> <span class="token comment">//输出 我是：shibin</span>
</code></pre></div><p>上面两个例子说明了什么是基本操作。那什么是非基本操作呢？其实调用对象下的方法就是典型的非基本操作，我们叫它<strong>复合类型</strong></p><div class="language-js"><pre><code>obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>调用函数的方法，由两个基本语义组成</p><ul><li>get ，即通过 get 操作得到 obj.fn 属性</li><li>函数调用，即通过 get 得到 obj.fn 的值后再调用它</li></ul><h3 id="reflect" tabindex="-1">Reflect <a class="header-anchor" href="#reflect" aria-hidden="true">#</a></h3><p>任何在 Proxy 的拦截器中能找到的方法，都能够在 Reflect</p><p>Reflect.get 就是提供了一个访问对象属性的默认功能。下面两种操作时等价的</p><div class="language-js"><pre><code><span class="token comment">// 直接读取</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token comment">// 使用 Reflect.get 获取</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 1</span>
</code></pre></div><p>既然操作等价，它存在的意义是什么呢？实际上， Reflect.get 还可以接收第三个参数，即指定接受者 receiver ，可以理解为函数调用过程中的 this 。</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 2</span>
</code></pre></div><p>看下我们之前实现的代码</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
            <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>之前我们并没有使用 Reflect ，我们先看下面代码，看看之前的实现存在的问题</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>bar<span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>运行下面代码</p><div class="language-js"><pre><code>obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre></div><p>我们发现并没有触发 effect 传递的副作用函数</p><p>我们在 get 函数中，通过 target[key] ，此时的 target 就是 obj ，target[key] 就相当于是 obj.bar ，最终访问的是 obj.foo</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token comment">// 这里 target 指的是 obj,</span>
            <span class="token comment">// 此时的 target[key] 就相当于是 obj.bar</span>
            <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
            <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这就等价于</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在副作用函数内没有访问它的代理对象，所以不会建立响应联系</p><p>这时候， Reflect.get 就派上用场了， Reflect.get 的第三个参数，它代表读取谁的属性</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时我们使用 Reflect.get 获取代理对象的 bar 属性，最终会访问代理对象的foo ，代理对象 foo 就会与副作用函数建立响应联系</p><div class="language-js"><pre><code>代理对象 p <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// this 指向的是代理对象</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="javascript-对象及-proxy-的工作原理" tabindex="-1">JavaScript 对象及 Proxy 的工作原理 <a class="header-anchor" href="#javascript-对象及-proxy-的工作原理" aria-hidden="true">#</a></h2><p>如何区分一个对象是普通对象还是函数？在 JavaScript 中，对象的实际语义是由对象的内部方法指定的。所谓内部方法，指的就是我们对一个对象操作时在引擎内部调用的方法，对于使用者来说是不可见的。</p><p>例如，当我们访问对象属性时：</p><div class="language-js"><pre><code>obj<span class="token punctuation">.</span>foo
</code></pre></div><p>引擎内部会调用 <code>[[Get]]</code> 这个内部方法来读取属性值。在 ECMAScript 规范中使用 <code>[[xxx]]</code> 来代表内部方法或内部槽</p><p>如果一个对象作为函数调用，那么这个对象内部必须部署内部方法 <code>[[Call]]</code></p><p>一个对象不仅部署了 <code>[[Get]]</code> 这个内部方法，还有很多其他的内部方法。<a href="https://tc39.es/ecma262/#sec-invariants-of-the-essential-internal-methods" target="_blank" rel="noopener noreferrer">相关链接</a></p><p>代理对象和普通对象没有太大区别，区别在于内部方法 <code>[[Get]]</code> 的实现。如果在创建代理对象时，没有指定对应的拦截函数，内部 <code>[[Get]]</code> 方法就会调用原始对象来获取属性值</p><p>Proxy 对象部署的所有内部方法</p><table><thead><tr><th>内部方法</th><th>处理器函数（拦截函数）</th></tr></thead><tbody><tr><td><code>[[GetPrototypeOf]]</code></td><td>getPrototypeOf</td></tr><tr><td><code>[[SetPrototypeOf]]</code></td><td>setPrototypeOf</td></tr><tr><td><code>[[IsExtensible]]</code></td><td>isExtensible</td></tr><tr><td><code>[[PreventExtensions]]</code></td><td>preventExtensions</td></tr><tr><td><code>[[GetOwnProperty]]</code></td><td>getOwnPropertyDescriptor</td></tr><tr><td><code>[[DefineOwnProperty]]</code></td><td>defineProperty</td></tr><tr><td><code>[[HasProperty]]</code></td><td>has</td></tr><tr><td><code>[[Get]]</code></td><td>get</td></tr><tr><td><code>[[Set]]</code></td><td>set</td></tr><tr><td><code>[[Delete]]</code></td><td>deleteProperty</td></tr><tr><td><code>[[OwnPropertyKeys]]</code></td><td>ownKeys</td></tr><tr><td><code>[[Call]]</code></td><td>apply</td></tr><tr><td><code>[[Construct]]</code></td><td>construct</td></tr></tbody></table><p>其中，<code>[[Call]]</code> 和 <code>[[Construct]]</code> 这两个内部方法，只有当被代理的对象是函数和构造函数时才会部署。</p><p>由上面的表中，我们可以知道拦截删除属性操作时，可以使用 deleteProperty 拦截函数实现</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="如何代理-object" tabindex="-1">如何代理 Object <a class="header-anchor" href="#如何代理-object" aria-hidden="true">#</a></h2><p>前面我们使用在 get 拦截函数去拦截对属性读取的操作。在响应式系统中，读取是一个很宽泛的改了，例如使用 in 操作检查对象上是否具有给定 key 也属于读取操作</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;foo&#39;</span> <span class="token keyword">in</span> obj
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>响应系统应该拦截一切读取操作，以便当数据发生变化能触发正确的响应。对一个对象的所有可能的读取操作有下面几种</p><ul><li>访问属性 obj.foo</li><li>判断对象或原型上是否存在给定的 key： key in obj</li><li>使用 for...in 循环遍历对象：for(const key in obj) {}</li></ul><h3 id="in-操作符拦截" tabindex="-1">in 操作符拦截 <a class="header-anchor" href="#in-操作符拦截" aria-hidden="true">#</a></h3><p>对于 in 操作符，并没有在表中找到相关操作的内容，怎么办呢？这时，就需要我们查看 in 操作符的相关规范</p><p>在 <a href="https://tc39.es/ecma262/" target="_blank" rel="noopener noreferrer">ECMA-262</a> 规范的 <a href="https://tc39.es/ecma262/#sec-relational-operators-runtime-semantics-evaluation" target="_blank" rel="noopener noreferrer">13.10.1</a>，明确定义了 in 操作符的运行逻辑</p><ol><li>Let lref be the result of evaluating RelationalExpression.</li><li>Let lval be ? GetValue(lref).</li><li>Let rref be the result of evaluating ShiftExpression.</li><li>Let rval be ? GetValue(rref).</li><li>If Type(rval) is not Object, throw a TypeError exception.</li><li>Return ? HasProperty(rval, ? ToPropertyKey(lval)).</li></ol><p>关键在第 6 步，in 操作符的运算结果是 HasProperty 对象返回的，我们在找到 <a href="https://tc39.es/ecma262/#sec-hasproperty" target="_blank" rel="noopener noreferrer">HasProperty</a> 的操作</p><ol><li>Return ? O.<code>[[HasProperty]]</code>(P)</li></ol><p>可以看到 HasProperty 的结果是调用内部的 <code>[[HasProperty]]</code> 方法得到的，<code>[[HasProperty]]</code> 对应的拦截方法是 has</p><p>因此，我们可以通过 has 拦截函数实现对 in 操作符的代理</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>当我们在副作用函数中使用 in 操作响应数据时，就能建立依赖关系</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;foo&#39;</span> <span class="token keyword">in</span> p
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="for-in-拦截" tabindex="-1">for...in 拦截 <a class="header-anchor" href="#for-in-拦截" aria-hidden="true">#</a></h3><p><a href="https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation" target="_blank" rel="noopener noreferrer">关于 for...in 执行规范</a></p><p>在第 6 步的 c 子步骤</p><p>c. Let iterator be EnumerateObjectProperties(obj).</p><p>关键点在 EnumerateObjectProperties(obj)。 EnumerateObjectProperties 是一个抽象方法，该方法返回一个迭代器对象，在 <a href="https://tc39.es/ecma262/#sec-enumerate-object-properties" target="_blank" rel="noopener noreferrer">14.7.9</a> 给出了满足该抽象方法实例的实现</p><div class="language-js"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">EnumerateObjectProperties</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> key <span class="token operator">===</span> <span class="token string">&quot;symbol&quot;</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> desc <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>desc<span class="token punctuation">.</span>enumerable<span class="token punctuation">)</span> <span class="token keyword">yield</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> proto <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> protoKey <span class="token keyword">of</span> <span class="token function">EnumerateObjectProperties</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>protoKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">yield</span> protoKey<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第三行使用了 Reflect.ownKeys 来获取只属于对象自身拥有的键。通过这个，我们就知道可以使用 ownKeys 拦截函数来拦截 Reflect.ownKeys 操作</p><div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token constant">ITERATE_KEY</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中，为什么要使用 ITERATE_KEY 作为追踪的 key？</p><ul><li>因为 ownKeys 拦截函数中，我们只能拿到目标对象 target</li><li>ownKeys 用来获取所有属于自己的属性，所以这个操作明显不予任何键进行绑定，只能构造一个唯一的 key 作为标识。</li></ul><p>那么在触发响应的时候也应该触发，那在什么时候触发响应呢？先看下面代码</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span>
</code></pre></div><p>对象 p 上本来不存在 bar 属性，effect 内部的副作用函数 for...in 会循环一次，当给对象添加属性 bar 时，需要触发副作用函数重新执行才可以</p><div class="language-js"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br></div><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 取得所有与 key 关联的副作用函数</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 取得所有与 ITERATE_KEY 关联的副作用函数</span>
    <span class="token keyword">const</span> iterateEffects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// ITERATE_KEY 关联的副作用函数 添加到 effectsToRun 中</span>
    iterateEffects <span class="token operator">&amp;&amp;</span> iterateEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这么做还会有一个问题，当我们设置属性时，也会触发 ITERATE_KEY 关联的副作用函数执行</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre></div><p>按理说，设置属性不会对for...in 循环产生影响，不应该更新，因为无论怎么修改，for...in 循环执行都只会执行一次</p><p>为了解决上面的问题，我们可以在设置属性时，在 set 拦截函数中先判断对象是否存在这个属性</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 属性存在，就是设置</span>
            <span class="token comment">// 不存在就是添加</span>
            <span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token string">&#39;SET&#39;</span><span class="token operator">:</span> <span class="token string">&#39;ADD&#39;</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中我们判断对象是否需存在这个属性，存在就是 SET 类型，不存在就是 ADD 类型</p><p>在 trigger 函数内部， 根据类型 决定是否需要触发 ITERATE_KEY 关联的副作用函数</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token keyword">const</span> iterateEffects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 只有 type 为 ADD 时，才触发与 ITERATE_KEY 关联的副作用函数</span>
    type <span class="token operator">===</span> <span class="token string">&#39;ADD&#39;</span> <span class="token operator">&amp;&amp;</span> iterateEffects <span class="token operator">&amp;&amp;</span> iterateEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了方便后期代码维护，需要将操作类型封装为一个枚举值</p><div class="language-js"><pre><code><span class="token keyword">const</span> TriggerType <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token constant">SET</span><span class="token operator">:</span> <span class="token string">&#39;SET&#39;</span><span class="token punctuation">,</span>
    <span class="token constant">ADD</span><span class="token operator">:</span> <span class="token string">&#39;ADD&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="delete-拦截" tabindex="-1">delete 拦截 <a class="header-anchor" href="#delete-拦截" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">delete</span> p<span class="token punctuation">.</span>foo
</code></pre></div><p>如何代理 delete 操作符，需要查看 <a href="https://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation" target="_blank" rel="noopener noreferrer">delete 规范</a> 。</p><p>第 5 步的内容如下</p><div class="language-"><pre><code>5. If IsPropertyReference(ref) is true, then
  a. Assert: IsPrivateReference(ref) is false.
  b. If IsSuperReference(ref) is true, throw a ReferenceError exception.
  c. Let baseObj be ? ToObject(ref.`[[Base]]`).
  d. Let deleteStatus be ? baseObj.`[[Delete]]`(ref.`[[ReferencedName]]`).
  e. If deleteStatus is false and ref.`[[Strict]]` is true, throw a TypeError exception.
  f. Return deleteStatus.
</code></pre></div><p>在第 5 步的 d 子步骤可知， delete 操作的行为依赖 <code>[[Delete]]</code> 内部方法，该内部方法对应的拦截函数为 deleteProperty</p><p>所以可以使用 deleteProperty 对删除属性进行拦截</p><div class="language-js"><pre><code><span class="token keyword">const</span> TriggerType <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token constant">SET</span><span class="token operator">:</span> <span class="token string">&#39;SET&#39;</span><span class="token punctuation">,</span>
    <span class="token constant">ADD</span><span class="token operator">:</span> <span class="token string">&#39;ADD&#39;</span><span class="token punctuation">,</span>
    <span class="token constant">DEL</span><span class="token operator">:</span> <span class="token string">&#39;DEL&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> hadKey <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token comment">// 只有删除成功且删除的属性是自己的属性时才触发更新</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&amp;&amp;</span> hadKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> TriggerType<span class="token punctuation">.</span><span class="token constant">DEL</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 取得所有与 key 关联的副作用函数</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 取得所有与 ITERATE_KEY 关联的副作用函数</span>
    <span class="token keyword">const</span> iterateEffects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 删除和添加属性时，需要触发 ITERATE_KEY 相关的副作用函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span> <span class="token operator">||</span> type <span class="token operator">===</span> TriggerType<span class="token punctuation">.</span><span class="token constant">DEL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        iterateEffects <span class="token operator">&amp;&amp;</span> iterateEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="合理的触发响应" tabindex="-1">合理的触发响应 <a class="header-anchor" href="#合理的触发响应" aria-hidden="true">#</a></h2><h3 id="新旧值处理" tabindex="-1">新旧值处理 <a class="header-anchor" href="#新旧值处理" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码中，p.foo 的值并没有发生变化，但是还是会再次触发副作用函数的执行。因此，当我们在调用 trigger 函数时，还需要判断新旧两个值是否相等</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> oldVal <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            <span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!==</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，上面代码存在缺陷，当原来的值时 NaN 时，我们再次设置的值还是 NaN ，使用全等比较总是为返回 false</p><div class="language-js"><pre><code><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span> <span class="token comment">// false</span>
<span class="token number">NaN</span> <span class="token operator">!==</span> <span class="token number">NaN</span> <span class="token comment">// true</span>
</code></pre></div><p>为了解决这个问题，我们需要在判断上加一个条件</p><div class="language-js"><pre><code><span class="token comment">// 当新旧值不相等且 新值和旧值不都是 NaN 的时候才触发更新</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>oldVal <span class="token operator">===</span> oldVal <span class="token operator">||</span> newVal <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="原型继承处理" tabindex="-1">原型继承处理 <a class="header-anchor" href="#原型继承处理" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> proto <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
<span class="token comment">// 使用 parent 作为 child 的原型</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>bar<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 修改 child.bar 的值，副作用函数会重新执行</span>
child<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><p>执行上面代码，当我们修改 child.bar 的值时，我们发现副作用函数执行了两次</p><p>分析原因</p><ul><li>当我们访问 child.bar 时，会将副作用函数添加到依赖中（child.bar）</li><li>由于 child 并不存在 bar 属性，所以会从原型上获取</li><li>访问原型的属性时，由于 parent 也是响应式的，所以会再次被添加到依赖中（parent.bar）</li><li>当设置 child.bar 的值时，会触发 child 的 set 拦截函数，使用 Reflect.set 会调用 obj对象上内部的 <code>[[set]]</code> 方法</li><li>如果设置的属性在对象上不存在，就会取得原型并调用原型的 set 方法，这就会导致，虽然我们设置的是 child.bar ，但还是会执行 parent.bar 的拦截函数被执行</li></ul><p>解决的办法就是屏蔽 parent.bar 触发的副作用函数给屏蔽就可以了。两次更新是由于 parent.bar 触发的副作用函数</p><p>child 的 set 拦截函数</p><div class="language-js"><pre><code><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// target 是原始对象 obj</span>
    <span class="token comment">// receiver 是代理对象 child</span>
<span class="token punctuation">}</span>
</code></pre></div><p>parent 的 set 拦截函数</p><div class="language-js"><pre><code><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// target 是原始对象 proto</span>
    <span class="token comment">// receiver 仍是代理对象 child</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们发现，两次 set 拦截函数中，target 是变化的，reveiver 都是 child ，根据这个区别，我们只需要判断receiver 是不是 target 的代理对象就可以了</p><p>首先我们需要给 get 拦截函数添加一个能力</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代理对象可以通过 raw 属性访问原始数据</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这时，代理对象就可以通过访问 raw 属性访问原始的数据对象</p><div class="language-js"><pre><code>child<span class="token punctuation">.</span>raw <span class="token operator">===</span> obj <span class="token comment">// true</span>
parent<span class="token punctuation">.</span>raw <span class="token operator">===</span> proto <span class="token comment">// true</span>
</code></pre></div><p>我们就可以在 set 拦截函数中判断 receiver 是不是 target 的代理对象了</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> oldVal <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            <span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>
            <span class="token comment">// 由于 key 不存在，所以会调用这里会触发原型上（parent）的 set 拦截</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token comment">// receiver 是 target 的代理对象</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> receiver<span class="token punctuation">.</span>raw<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>oldVal <span class="token operator">===</span> oldVal <span class="token operator">||</span> newVal <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="浅响应与深响应" tabindex="-1">浅响应与深响应 <a class="header-anchor" href="#浅响应与深响应" aria-hidden="true">#</a></h2><h3 id="深响应" tabindex="-1">深响应 <a class="header-anchor" href="#深响应" aria-hidden="true">#</a></h3><p>在之前，我们实现的响应式都是浅响应的，例如下面代码</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改 bar 的值，并不能触发响应</span>
    p<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token operator">++</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>修改 p.foo.bar 的值，并不能触发响应，什么原因呢？</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代理对象可以通过 raw 属性访问原始数据</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面代码，我们可以看到，当访问 p.foo.bar 时，首先要读取 p.foo，这里我们直接返回了 Reflect.get 得到的 p.foo 这个结果，由于这个结果是一个普通对象（{bar: 1}），所以它并不是一个响应式的。要解决这个问题，我们需要对 Reflect 做一个包装</p><div class="language-js"><pre><code> <span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代理对象可以通过 raw 属性访问原始数据</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token comment">// 得到原始值结果</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 将结果包装成响应式的返回</span>
                <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre></div><h3 id="浅响应" tabindex="-1">浅响应 <a class="header-anchor" href="#浅响应" aria-hidden="true">#</a></h3><p>有的时候我们希望我们的数据是浅响应的（shallowReactive），就是只有第一层属性是响应的，这时我们只需要在我们原来的代码中稍加修改就可以了</p><div class="language-js"><pre><code> <span class="token keyword">function</span> <span class="token function">createReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代理对象可以通过 raw 属性访问原始数据</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token comment">// 得到原始值结果</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isShallow<span class="token punctuation">)</span> <span class="token keyword">return</span> res
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 将结果包装成响应式的返回</span>
                <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token comment">//  浅响应</span>
<span class="token keyword">function</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 深响应</span>
<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="只读和浅只读" tabindex="-1">只读和浅只读 <a class="header-anchor" href="#只读和浅只读" aria-hidden="true">#</a></h2><p>有时候我们希望我们的数据时只读的，当用户修改数据时，会给用户一个警告。例如组件接收的 props。</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">readonly</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 尝试修改数据，会给出一条警告</span>
obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><p>为 createReactive 函数增加第三个参数 isReadonly</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果属性是只读的，就打印信息并返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 是只读的</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> oldVal <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            <span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> receiver<span class="token punctuation">.</span>raw<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>oldVal <span class="token operator">===</span> oldVal <span class="token operator">||</span> newVal <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果属性是只读的，就打印信息并返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 是只读的</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> hadKey <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&amp;&amp;</span> hadKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> TriggerType<span class="token punctuation">.</span><span class="token constant">DEL</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>修改操作可以在 set 和 deleteProperty 拦截函数进行拦截，如果数据时<strong>只读</strong>的，那么就<strong>无法修改</strong>它。所以也<strong>没必要为只读数据建立响应联系</strong></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代理对象可以通过 raw 属性访问原始数据</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token comment">// 非只读才需要建立响应联系</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isShallow<span class="token punctuation">)</span> <span class="token keyword">return</span> res
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">readonly</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中实现的是浅只读的</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代理对象可以通过 raw 属性访问原始数据</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token comment">// 非只读才需要建立响应联系</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token comment">// 浅只读它的属性不是相应式的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isShallow<span class="token punctuation">)</span> <span class="token keyword">return</span> res
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果是只读，调用 readonly 进行包装</span>
                <span class="token keyword">return</span> isReadonly <span class="token operator">?</span> <span class="token function">readonly</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于深只读，我们需要把它的属性值也调用 readonly 函数进行包装</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">readonly</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">shallowReadonly</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于浅只读，只需要修改第二个参数 isShallow 为 true 就可以了（既是浅只读，也是浅相应）。</p><h2 id="代理数组" tabindex="-1">代理数组 <a class="header-anchor" href="#代理数组" aria-hidden="true">#</a></h2><p>在 JavaScript 中，数组只是一个普通的对象，对数组的代理需要了解它与普通对象有什么区别。数组是一个异质对象，因为数组内部的 <code>[[DefineOwnProperty]]</code> 这个内置方法与常规对象不同。除了 <code>[[DefineOwnProperty]]</code> 这个内部方法外，其他内部方法逻辑都与常规相同。所以，实现数组对象的代理，代理普通对象的绝大部分代码可以继续使用</p><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 可以触发响应</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
</code></pre></div><p>数组与普通对象的操作有所不同，下面列举了所有数组元素的读取操作</p><ul><li>通过索引访问数组的元素值</li><li>访问数组的长度</li><li>把数组作为对象，使用 for...in 循环遍历</li><li>使用 for...of 迭代遍历数组</li><li>数组的原型方法。（如 concat 、join 、 every 、 some 、 find 、 findIndex 、 includes 等）</li></ul><p>对数组的设置操作</p><ul><li>通过索引修改数组的元素值</li><li>修改数组的长度</li><li>数组的栈方法 （如push 、 pop 、 shift 、 unshift）</li><li>修改原数组的原型方法 （如splice 、fill 、sort）</li></ul><h3 id="数组的索引与-length" tabindex="-1">数组的索引与 length <a class="header-anchor" href="#数组的索引与-length" aria-hidden="true">#</a></h3><p>当我们通过索引修改数组元素的值时，会执行数组内部所部署的内部方法 <code>[[Set]]</code> ，<code>[[Set]]</code> 方法依赖于 <code>[[DefineOwnProperty]]</code>。<a href="https://tc39.es/ecma262/#sec-array-exotic-objects-defineownproperty-p-desc" target="_blank" rel="noopener noreferrer">相关链接</a></p><p>由规范可知，如果设置数组的索引大于数组的长度，那么要更新数组的 length 属性，在触发响应时，也应该触发与 length 相关的副作用函数，我们需要修改 set 拦截函数</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 是只读的</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> oldVal <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>

            <span class="token keyword">const</span> type <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
                <span class="token comment">// 数组对象 设置的索引值 &lt; 数组的长度，就是 SET 否则是 ADD</span>
                <span class="token operator">?</span> <span class="token function">Number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">.</span>length <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>
                <span class="token comment">// 普通对象</span>
                <span class="token operator">:</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>

            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token comment">// receiver 是 target 的代理对象</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> receiver<span class="token punctuation">.</span>raw<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>oldVal <span class="token operator">===</span> oldVal <span class="token operator">||</span> newVal <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 set 拦截函数中，如果目标对象是数组</p><ul><li>索引值 &lt; 数组长度 ， type 就是 SET</li><li>否则 type 就是 ADD</li></ul><p>有了类型 type 之后，就可以在 trigger 函数中正确的触发响应</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token comment">// 操作类型是 ADD 且 是数组时，应执行所有与 length 相关的副作用函数</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span> <span class="token operator">&amp;&amp;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> lengthEffects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;length&#39;</span><span class="token punctuation">)</span>
        lengthEffects <span class="token operator">&amp;&amp;</span> lengthEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>反过来，当修改数组的 length 属性也会隐式地影响数组元素。例如</p><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 会受到影响</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 不会受到影响</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><p>当设置的 length 的值比访问的索引值小时，会触发响应。这就需要我们把新设置的属性值传递给 trigger 函数</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 是只读的</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> oldVal <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>

            <span class="token keyword">const</span> type <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
                <span class="token operator">?</span> <span class="token function">Number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">.</span>length
                    <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>
                <span class="token operator">:</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
                    <span class="token operator">?</span> TriggerType<span class="token punctuation">.</span><span class="token constant">SET</span> <span class="token operator">:</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span>

            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> receiver<span class="token punctuation">.</span>raw<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>oldVal <span class="token operator">===</span> oldVal <span class="token operator">||</span> newVal <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 将新的属性值传递给 trigger 函数</span>
                    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> type<span class="token punctuation">,</span> newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token comment">//  是数组时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 操作类型是 ADD  应执行所有与 length 相关的副作用函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> TriggerType<span class="token punctuation">.</span><span class="token constant">ADD</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> lengthEffects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;length&#39;</span><span class="token punctuation">)</span>
            lengthEffects <span class="token operator">&amp;&amp;</span> lengthEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 修改数组的长度</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;length&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            depsMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">effects<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当前索引 &gt;= 新设置的数组的长度时，需要执行副作用函数</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;=</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">!==</span> effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="for-in" tabindex="-1">for...in <a class="header-anchor" href="#for-in" aria-hidden="true">#</a></h3><p>我们应该<strong>尽量避免</strong>使用 for...in 循环遍历数组。语法上可以使用，所以也应该考虑这种情况</p><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>数组对象的 for...in 循环与遍历的常规对象并无差异，因此可以使用 ownKeys 拦截函数进行拦截。</p><p>之前实现的拦截函数</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
            <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>对于普通对象，只有添加或删除属性时，会影响 for...in 遍历的结果，但数组有所不同</p><ul><li>添加新元素， arr[100] = 100</li><li>修改数组元素，arr.length = 0</li></ul><p>无论为数组添加新元素，还是直接修改数组的长度，本质上都修改了数组的长度。都会影响 for...in 遍历的结果，所以在 ownKeys 拦截函数中，我们可以使用 length 作为 key 去作为响应联系</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是数组，就使用 length 属性作为 key</span>
            Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token string">&#39;length&#39;</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>添加新元素， arr[100] = 100 <ul><li>trigger 函数中会根据类型是 ADD，触发跟 length 相关的副作用函数， for...in 就会触发</li></ul></li><li>修改数组元素，arr.length = 0 <ul><li>trigger 函数会判断 当前索引 &gt;= 新设置的数组的长度时，需要执行副作用函数</li></ul></li></ul><h3 id="for-of" tabindex="-1">for...of <a class="header-anchor" href="#for-of" aria-hidden="true">#</a></h3><p>for...of 用来遍历<strong>可迭代对象</strong>的。ES2015 为 JavaScript 定义了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener noreferrer">迭代协议</a>，它不是新的语法，而是一种协议。一个对象能否被迭代，取决于该对象或该对象的原型是否实现了 @@iterator 方法。</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>这里的 @@[name] 标志在 ESMAScript 规范里用来代指 JavaScript 内建的 symbols 值，@@iterator 指的就是 Symbol.iterator</p></div><p>如果一个对象实现了 Symbol.iterator 方法， 那么这个对象就是可迭代的。例如</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">val</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span> obj<span class="token punctuation">.</span>val<span class="token operator">++</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">done</span><span class="token operator">:</span> obj<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对象 obj 实现了 Symbol.iterator 方法，因此可以使用 for...of 循环遍历它</p><p>数组内建了 Symbol.iterator 方法的实现</p><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>

<span class="token keyword">const</span> itr <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 1, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 2, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 3, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 4, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 5, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: undefined, done: true}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> val <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// 1, 2, 3, 4, 5</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据 ECMA 规范，数组迭代器质性会读取数组的 length 属性，如果迭代的是数组的元素值，还会读取数组的索引。下面是模拟数组迭代器的实现</p><div class="language-js"><pre><code>arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> target<span class="token punctuation">.</span>length
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                <span class="token literal-property property">value</span><span class="token operator">:</span> index <span class="token operator">&lt;</span> len <span class="token operator">?</span> target<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
                <span class="token literal-property property">done</span><span class="token operator">:</span> index<span class="token operator">++</span> <span class="token operator">&gt;</span> len
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，在不增加任何代码的情况下，我们的数组迭代方法也可以正确的触发响应</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> val <span class="token keyword">of</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 能够触发响应</span>
p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">22</span>
</code></pre></div><p>数组的 values 方法的返回值实际上就是数组内建的迭代器</p><div class="language-js"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>values <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> val <span class="token keyword">of</span> p1<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 能够触发响应</span>
p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">22</span>
</code></pre></div><p>无论是调用 for...of 循环，还是调用 values 方法等，他们都会读取 Symbol.iterator 属性，该属性是一个 symbol 值，为了避免发生意外以及性能上的考虑，不应该让副作用函数与 Symbol.iterator 这类 symbol 值之间建立响应联系。</p><p>修改 get 拦截函数</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token comment">// key 是 symbol 则不追踪</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> key <span class="token operator">!==</span> <span class="token string">&#39;symbol&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isShallow<span class="token punctuation">)</span> <span class="token keyword">return</span> res
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> isReadonly <span class="token operator">?</span> <span class="token function">readonly</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
</code></pre></div><h3 id="数组的查找方法" tabindex="-1">数组的查找方法 <a class="header-anchor" href="#数组的查找方法" aria-hidden="true">#</a></h3><p>数组的内部方法都依赖了对象的基本语义，所以大多数情况下，我们无须做特殊处理即可达到预期</p><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// 会触发副作用打印 false</span>
</code></pre></div><p>这是因为 includes 方法为了找到给定的值，会访问数组的 length 属性以及数组的索引</p><p>然而 incluses 方法并不总是能够达到预期</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span>obj<span class="token punctuation">]</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>当我们访问 includes 方法，内部方法会通过索引获取数组元素的值 ，会访问到 arr[0]，触发 get 方法拦截</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果值时对象，就会调用 reactive 返回一个新的代理对象</span>
                <span class="token keyword">return</span> isReadonly <span class="token operator">?</span> <span class="token function">readonly</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到每次触发 get 方法，由于数组元素的值时对象，所以每次返回的都是一个新的代理对象，所以就导致 arr[0]!==arr[0]</p><div class="language-js"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>所以，要解决这个问题，就要将我们代理过的对象保存下来，再次访问时不需要再重新创建</p><p>先将原来的 reactive 函数名修改为 createReactive</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">createReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> key <span class="token operator">!==</span> <span class="token string">&#39;symbol&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isShallow<span class="token punctuation">)</span> <span class="token keyword">return</span> res
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> isReadonly <span class="token operator">?</span> <span class="token function">readonly</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 reactive 函数中，我们使用一个 Map 用来存在代理对象的映射</p><div class="language-js"><pre><code><span class="token keyword">const</span> reactiveMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> exitProxyMap <span class="token operator">=</span> reactiveMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>exitProxyMap<span class="token punctuation">)</span> <span class="token keyword">return</span> exitProxyMap
    <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">createReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> isShallow<span class="token punctuation">,</span> isReadonly<span class="token punctuation">)</span>
    reactiveMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> proxy<span class="token punctuation">)</span>
    <span class="token keyword">return</span> proxy
<span class="token punctuation">}</span>
</code></pre></div><p>运行下面代码，发现符合预期</p><div class="language-js"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>再看下面代码</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span>obj<span class="token punctuation">]</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>这个比较符合用户的习惯，我们知道，obj是原始对象，arr.includes 方法指向的是内部的代理对象，所以肯定查找不到</p><p>所以，我们需要重写数组的 includes 方法并实现自定义行为</p><div class="language-js"><div class="highlight-lines"><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span class="token keyword">const</span> arrayInstrumentations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">includes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">createReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> isShallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isReadonly <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;raw&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> target
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果是数组并且 key 存在于 arrayInstrumentations 上 如 includes</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arrayInstrumentations<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>arrayInstrumentations<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> key <span class="token operator">!==</span> <span class="token string">&#39;symbol&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isShallow<span class="token punctuation">)</span> <span class="token keyword">return</span> res
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> res <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> isReadonly <span class="token operator">?</span> <span class="token function">readonly</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> res
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行 arr.includes 方法就相当于执行 arrayInstrumentations.includes 方法</p><div class="language-js"><pre><code><span class="token keyword">const</span> originMethod <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>includes
<span class="token keyword">const</span> arrayInstrumentations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">includes</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的 this 指向代理对象 </span>
        <span class="token comment">// 首先调用 代理对象的 includes 方法</span>
        <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">originMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 调用原始对象的 includes 方法</span>
            res <span class="token operator">=</span> <span class="token function">originMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>raw<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行过程中先调用代理对象的 includes 方法进行查找，如果查找不到，就调用原始对象的 includes 方法进行查找</p><p>需要做类似的处理方法还有 indexOf 、lastIndexOf</p><div class="language-js"><pre><code><span class="token keyword">const</span> arrayInstrumentations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token string">&#39;includes&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;indexOf&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;lastIndexOf&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">method</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> originMethod <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
    arrayInstrumentations<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的 this 指向代理对象 </span>
        <span class="token comment">// 首先调用 代理对象的方法</span>
        <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">originMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 调用原始对象的方法</span>
            res <span class="token operator">=</span> <span class="token function">originMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>raw<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> resv
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="隐式修改数组长度的原型方法" tabindex="-1">隐式修改数组长度的原型方法 <a class="header-anchor" href="#隐式修改数组长度的原型方法" aria-hidden="true">#</a></h3><p>隐式修改数组长度的方法主要是栈方法，例如 push 、pop 、 shift 、 unshift 、 splice</p><p>以 push 方法为例，从<a href="https://tc39.es/ecma262/#sec-array.prototype.push" target="_blank" rel="noopener noreferrer">push 方法的执行流程</a>中，第 2 步 和第 6 步可知，当调用数组的 push 方法时，既会读取数组的 length 属性，也会设置数组的 length 属性，这会导致两个独立的副作用函数相互影响。</p><p>例如下面代码</p><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>运行后会得到栈移除的错误</p><div class="language-"><pre><code>Uncaught RangeError: Maximum call stack size exceeded
</code></pre></div><p>问题的原因就是 push 方法会间接读取 length 的属性，所以需要屏蔽对length 属性的读取即可，从而避免它与副作用函数之间建立响应联系。因为数组的 push 方法在语义上是修改操作，而非读取操作。</p><div class="language-js"><pre><code><span class="token keyword">let</span> shouldTrack <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token string">&#39;push&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">method</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> originMethod <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
    arrayInstrumentations<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        shouldTrack <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">originMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        shouldTrack <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>使用 shouldTrack 做标记，当我们调用 push 时， shouldTrack 赋值为 false ，执行原始的 push 方法会执行 track 函数，在track 函数中根据 shouldTrack 来判断它是否需要追踪，shouldTrack 是 false ，就直接返回。执行完原始的 push 方法后，就将 shouldTrack 值还原为 true</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// shouldTrack 为 false 直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect <span class="token operator">||</span> <span class="token operator">!</span>shouldTrack<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再执行之前的测试代码，能够正常运行</p><p>除了 push ，pop 、 shift 、 unshift 、 splice 都需要类似的处理</p><div class="language-js"><pre><code><span class="token keyword">let</span> shouldTrack <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token string">&#39;push&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;pop&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;shift&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;unshift&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">method</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> originMethod <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
    arrayInstrumentations<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        shouldTrack <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">originMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        shouldTrack <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="代理集合类型" tabindex="-1">代理集合类型 <a class="header-anchor" href="#代理集合类型" aria-hidden="true">#</a></h2><p>集合类型包括 Map/Set 以及 WeakMap/WeakSet。</p><p>使用 Proxy 代理集合类型的数据与代理普通对象不同，因为集合类型的操作与普通对象存在很大的不同</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener noreferrer">Set 相关介绍</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener noreferrer">Map 相关介绍</a></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener noreferrer">Set</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener noreferrer">Map</a> 这两种数据类型的操作方法类似，它们之间最大的不同在于 Set 类型使用 add(value) 添加元素， 而 Map 类型使用 set(key, value) 方法设置键值对，并且 Map 类型可以使用 get(key) 方法读取相应的值。所以，大多数情况下我们可以使用相同的方法来处理 Set 和 Map 。</p><h3 id="如何代理-set-和-map" tabindex="-1">如何代理 Set 和 Map <a class="header-anchor" href="#如何代理-set-和-map" aria-hidden="true">#</a></h3><p>执行下面代码，我们希望修改后能正常触发响应</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&#39;key&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;key&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;key&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 能触发响应</span>
</code></pre></div><p>但实际上会报错</p><div class="language-"><pre><code>Uncaught TypeError: Method Map.prototype.get called on incompatible receiver 
</code></pre></div><p>同样运行下面代码也会报错</p><div class="language-js"><pre><code><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
</code></pre></div><p><a href="https://tc39.es/ecma262/#sec-get-set.prototype.size" target="_blank" rel="noopener noreferrer">查看 Set.prototype.set 的执行过程</a>，关键在第 1 步和第 2 步，第 1 步中，this 指向代理对象（因为是通过代理对象访问的），第 2 步，调用抽象方法 <code>RequireInternalSlot(M, [[SetData]])</code> 来检查代理对象 M 是否存在内部槽 <code>[[MapData]]</code>，代理对象中不存在 <code>[[SetData]]</code> ，所以执行后就会抛出错误</p><p>为了解决这个问题，我们需要修正访问器的 getter 函数执行时 this 的指向</p><div class="language-js"><pre><code><span class="token comment">// 为了简洁，这里只做 map set 的处理</span>
<span class="token keyword">function</span> <span class="token function">createReactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是 size 属性，</span>
            <span class="token comment">// 指定 receiver 为原始对象 target 从而修复问题</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;size&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再次运行，发现运行后结果正常</p><div class="language-js"><pre><code><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><p>在之前，我们看到调用 map.get 同样会报错，s.size 与 p.get 不同，当访问 p.get 时（访问时 p.get 方法并没有执行），无论怎么修改 receiver ，执行 get 方法时的 this 指向都是代理对象，我们可以在 getter 方法中把 get 方法与原始数据绑定在一起即可</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">createReactive</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;size&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 改变执行方法时的 this 指向</span>
            <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行后，代码正常工作</p><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&#39;key&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;key&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="建立响应联系" tabindex="-1">建立响应联系 <a class="header-anchor" href="#建立响应联系" aria-hidden="true">#</a></h3></div></div><footer class="page-footer" data-v-0b036348 data-v-7fbac81a><div class="edit" data-v-7fbac81a><div class="edit-link" data-v-7fbac81a data-v-fb73da26><!----></div></div><div class="updated" data-v-7fbac81a><!----></div></footer><div class="next-and-prev-link" data-v-0b036348 data-v-57a2b8c7><div class="container" data-v-57a2b8c7><div class="prev" data-v-57a2b8c7><a class="link" href="/vue-design/guide/reactivity/function-and-realization" data-v-57a2b8c7><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-57a2b8c7><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-57a2b8c7>响应系统的作用与实现</span></a></div><div class="next" data-v-57a2b8c7><a class="link" href="/vue-design/guide/reactivity/original" data-v-57a2b8c7><span class="text" data-v-57a2b8c7>原始值的响应式方案</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-57a2b8c7><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"guide_design_art.md\":\"9cb03190\",\"guide_design_elements.md\":\"db068aa2\",\"guide_design_thinking.md\":\"a26612e0\",\"guide_reactivity_function-and-realization.md\":\"124a76ad\",\"guide_reactivity_non-original.md\":\"44a5ca92\",\"guide_reactivity_original.md\":\"462c3b6c\",\"index.md\":\"41fdfcb6\"}")</script>
    <script type="module" async src="/vue-design/assets/app.148e1184.js"></script>
    
  </body>
</html>