<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>响应系统的作用与实现 | Vue.js 设计与实现</title>
    <meta name="description" content="《Vue.js 设计与实现》笔记">
    <link rel="stylesheet" href="/vue-design/assets/style.298c1d36.css">
    <link rel="modulepreload" href="/vue-design/assets/app.43db1add.js">
    <link rel="modulepreload" href="/vue-design/assets/guide_reactivity_function-and-realization.md.3dae69b3.lean.js">
    
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
  <meta name="twitter:title" content="响应系统的作用与实现 | Vue.js 设计与实现">
  <meta property="og:title" content="响应系统的作用与实现 | Vue.js 设计与实现">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-ee8a9d28><div class="sidebar-button" data-v-ee8a9d28><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/vue-design/" aria-label="Vue.js 设计与实现, back to home" data-v-ee8a9d28 data-v-0922d34c><img class="logo" src="/vue-design/logo.svg" alt="Logo" data-v-0922d34c> Vue.js 设计与实现</a><div class="flex-grow" data-v-ee8a9d28></div><div class="nav" data-v-ee8a9d28><nav class="nav-links" data-v-ee8a9d28 data-v-420ed8ec><!--[--><div class="item" data-v-420ed8ec><div class="nav-link" data-v-420ed8ec data-v-60d4a991><a class="item" href="/vue-design/" data-v-60d4a991>首页 <!----></a></div></div><div class="item" data-v-420ed8ec><div class="nav-link" data-v-420ed8ec data-v-60d4a991><a class="item" href="/vue-design/design/art" data-v-60d4a991>指南 <!----></a></div></div><div class="item" data-v-420ed8ec><div class="nav-dropdown-link" data-v-420ed8ec data-v-79d15fd6><button class="button" data-v-79d15fd6><span class="button-text" data-v-79d15fd6>相关链接</span><span class="right button-arrow" data-v-79d15fd6></span></button><ul class="dialog" data-v-79d15fd6><!--[--><li class="dialog-item" data-v-79d15fd6><div class="nav-dropdown-link-item" data-v-79d15fd6 data-v-91374f62><a class="item isExternal" href="https://vuejs.org" target="_blank" rel="noopener noreferrer" data-v-91374f62><span class="arrow" data-v-91374f62></span><span class="text" data-v-91374f62>Vue.js 文档</span><span class="icon" data-v-91374f62><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-91374f62><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><li class="dialog-item" data-v-79d15fd6><div class="nav-dropdown-link-item" data-v-79d15fd6 data-v-91374f62><a class="item isExternal" href="https://v2.vuejs.org" target="_blank" rel="noopener noreferrer" data-v-91374f62><span class="arrow" data-v-91374f62></span><span class="text" data-v-91374f62>Vue.js 2 文档</span><span class="icon" data-v-91374f62><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-91374f62><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-420ed8ec><div class="nav-link" data-v-420ed8ec data-v-60d4a991><a class="item isExternal" href="https://github.com/coddingus/vue-design" target="_blank" rel="noopener noreferrer" data-v-60d4a991>Github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-60d4a991><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-61a655a3><nav class="nav-links nav" data-v-61a655a3 data-v-420ed8ec><!--[--><div class="item" data-v-420ed8ec><div class="nav-link" data-v-420ed8ec data-v-60d4a991><a class="item" href="/vue-design/" data-v-60d4a991>首页 <!----></a></div></div><div class="item" data-v-420ed8ec><div class="nav-link" data-v-420ed8ec data-v-60d4a991><a class="item" href="/vue-design/design/art" data-v-60d4a991>指南 <!----></a></div></div><div class="item" data-v-420ed8ec><div class="nav-dropdown-link" data-v-420ed8ec data-v-79d15fd6><button class="button" data-v-79d15fd6><span class="button-text" data-v-79d15fd6>相关链接</span><span class="right button-arrow" data-v-79d15fd6></span></button><ul class="dialog" data-v-79d15fd6><!--[--><li class="dialog-item" data-v-79d15fd6><div class="nav-dropdown-link-item" data-v-79d15fd6 data-v-91374f62><a class="item isExternal" href="https://vuejs.org" target="_blank" rel="noopener noreferrer" data-v-91374f62><span class="arrow" data-v-91374f62></span><span class="text" data-v-91374f62>Vue.js 文档</span><span class="icon" data-v-91374f62><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-91374f62><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><li class="dialog-item" data-v-79d15fd6><div class="nav-dropdown-link-item" data-v-79d15fd6 data-v-91374f62><a class="item isExternal" href="https://v2.vuejs.org" target="_blank" rel="noopener noreferrer" data-v-91374f62><span class="arrow" data-v-91374f62></span><span class="text" data-v-91374f62>Vue.js 2 文档</span><span class="icon" data-v-91374f62><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-91374f62><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-420ed8ec><div class="nav-link" data-v-420ed8ec data-v-60d4a991><a class="item isExternal" href="https://github.com/coddingus/vue-design" target="_blank" rel="noopener noreferrer" data-v-60d4a991>Github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-60d4a991><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-61a655a3><!--[--><li class="sidebar-link"><p class="sidebar-link-item">框架设计概览</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/design/art">权衡的艺术</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/design/elements">框架设计的核心要素</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/design/thinking">Vue.js 3 的设计思路</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">响应系统</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item active" href="/vue-design/guide/reactivity/function-and-realization">响应系统的作用与实现</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#响应式数据与副作用函数">响应式数据与副作用函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#响应式数据的基本实现">响应式数据的基本实现</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#设计一个完善的响应系统">设计一个完善的响应系统</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#分支切换与-cleanup">分支切换与 cleanup</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#分支切换">分支切换</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#建立关联">建立关联</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#cleanup">cleanup</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#嵌套的-effect-与-effect-栈">嵌套的 effect 与 effect 栈</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/reactivity/non-original">非原始值的响应式方案</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue-design/guide/reactivity/original">原始值的响应式方案</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-70cd7a5b><div class="container" data-v-70cd7a5b><!--[--><!--]--><div style="position:relative;" class="content" data-v-70cd7a5b><div><h1 id="响应系统的作用与实现" tabindex="-1">响应系统的作用与实现 <a class="header-anchor" href="#响应系统的作用与实现" aria-hidden="true">#</a></h1><p>响应式是 Vue.js 的重要组成部分</p><h2 id="响应式数据与副作用函数" tabindex="-1">响应式数据与副作用函数 <a class="header-anchor" href="#响应式数据与副作用函数" aria-hidden="true">#</a></h2><p>副作用就是会产生副作用的函数（就是一个函数的执行会对外部产生影响），如下面代码所示</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&#39;hello vue3&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>副作用很容易产生，例如一个函数修改了全局变量等</p><p>下面再来说下什么是响应式数据</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span>
</code></pre></div><p>例如我修改 obj.text 值，我们希望 effect 函数重新执行。如果实现了这个效果，那么 obj 就是一个响应式数据</p><div class="language-js"><pre><code>obj<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&#39;hello vue3&#39;</span>
</code></pre></div><p>很明显，上面的代码做不到这一点，因为 obj 是一个普通对象，修改值时不会有其他反应</p><h2 id="响应式数据的基本实现" tabindex="-1">响应式数据的基本实现 <a class="header-anchor" href="#响应式数据的基本实现" aria-hidden="true">#</a></h2><p>怎么才能使上面的 obj 变成响应式数据呢？我们能发现两个线索</p><ul><li>当副作用函数执行时，会触发字段 obj.text 的读取操作</li><li>当修改 obj.text 的值时，会触发 obj.text 的设置操作</li></ul><p>那么如果我们我在读取和设置的时候进行拦截不就可以了吗</p><p>接下来我们就使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy</a> 来实现对 obj 属性的拦截。具体代码如下：</p><div class="language-js"><pre><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span>

<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 读取操作拦截</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
        <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 设置操作拦截</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
        bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>使用代码测试下</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&#39;hello vue3&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>在浏览器运行，我们就会看到 1 秒后文字发生了改变，达到了我们想要的效果</p><p>但我们会发现，我们的拦截读取操作时，直接把副作用函数给写进去了，明显不够灵活。如果副作用函数能够自动添加进入就好了。比如我们修改函数名为 myEffect 甚至是匿名函数</p><h2 id="设计一个完善的响应系统" tabindex="-1">设计一个完善的响应系统 <a class="header-anchor" href="#设计一个完善的响应系统" aria-hidden="true">#</a></h2><p>为了解决上面的问题，我们首先需要一个用来注册副作用函数的机制</p><div class="language-js"><pre><code><span class="token comment">// 用于存储被注册的全局副作用函数</span>
<span class="token keyword">let</span> activeEffect

<span class="token comment">// 用于注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    activeEffect <span class="token operator">=</span> fn
    <span class="token comment">// 执行副作用函数</span>
    <span class="token function">activeEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>effect 函数调用时，会传递一个函数，这个函数可以为任意函数。当调用 effect 函数时，这个activeEffect 值就会赋值Wie当前的 effect 函数传递的函数并执行传递的函数。</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>当传递的这个函数执行时，如果读取了 obj 对象，那么它就会触发 get 拦截，我们在拦截过程中将 activeEffect 添加到 bucket 队列中就可以了</p><div class="language-js"><pre><code><span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
        bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>然后我们再对上面代码进行测试，当我们访问一个不存在的属性时</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;effect run&#39;</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>notExist <span class="token operator">=</span> <span class="token string">&#39;hello vue3&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>运行上面代码时，我们会发现控制台打印了两次 <code>effect run</code> ，而我们 obj.text 的值并未发生修改，而我们是希望仅当 text 值发生改变是，才会重新触发匿名函数的执行。导致该问题的原因是没有在副作用函数和被操作的字段之间建立明确的联系，解决方法很简单，只需要在副作用函数与被操作的字段建立联系即可。</p><p>我们再来看下面代码</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>代码中存在三个角色</p><ul><li>被操作的代理对象 obj</li><li>被操作的字段 text</li><li>使用 effect 函数注册的副作用函数 effectFn</li></ul><p>如果用 target 来表示代理对象所代理的原始值，用 key 字段来表示被操作的字段名，用 effectFn 来表示被注册的副作用函数，那么可以为这三个角色建立如下关系</p><div class="language-"><pre><code>target
  └── key
       └── effectFn
</code></pre></div><p>有两个副作用函数读取同一个对象</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>那么对应关系就是:</p><div class="language-"><pre><code>target
  └── text
       ├── effectFn1
       └── effectFn2
</code></pre></div><p>一个副作用函数读取了同一对象上的两个属性</p><div class="language-js"><pre><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>text1<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>text2<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>那么对应关系就是:</p><div class="language-"><pre><code>target
  └── text1
      └──  effectFn
  └── text2
      └──  effectFn
</code></pre></div><p>实现思路如下</p><ul><li>首先使用 bucket 来存储副作用函数， bucket 使用 WeakMap</li><li>当触发代理对象的 get 方法时，我们可以获取到 target 、key <ul><li>将 target 作为 key 存储到 bucket 上, 值为 depsMap，数据结构是 Map</li><li>将 key 作为 key ，deps 为值depsMap 中</li><li>将副作用函数添加到 deps 中</li></ul></li></ul><p><img src="/vue-design/04/reactivity.png" alt=""></p><p>实现代码如下：</p><div class="language-js"><pre><code><span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
        <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>接下来，再对上面代码进行封装。我们把拦截的逻辑都写在了 get 和 set 方法中，但更好的做法是吧这部分逻辑封装到一个函数中。</p><div class="language-js"><pre><code> <span class="token comment">// get 拦截函数内调用 track 函数触发追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// set 拦截函数内调用 trigger 函数触发变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
        <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这样我们就将追踪变化函数封装到 track 中，触发逻辑封装到 trigger 函数中</p><p>接下来说下为什么 bucket 要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener noreferrer">WeakMap</a> ，先看下面代码</p><div class="language-js"><pre><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> weakmap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">}</span>
    <span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">}</span>
    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    weakmap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>weakmap<span class="token punctuation">)</span>
</code></pre></div><p>当函数 fn 执行完毕后，对于 foo 对象来说，它依然作为 map 的 key 被引用着，因此垃圾回收器不会把它从内存中移除，我们依然可以在控制台看到 map 中存在 key 为 foo 对象的属性；由于 WeakMap 是弱类型引用，他不会影响垃圾回收器的工作，所以一旦函数 fn 执行完毕，就会把 bar 对象从内存中移除，并且 weakmap 中也不会存在 bar 对象这个属性</p><h2 id="分支切换与-cleanup" tabindex="-1">分支切换与 cleanup <a class="header-anchor" href="#分支切换与-cleanup" aria-hidden="true">#</a></h2><h3 id="分支切换" tabindex="-1">分支切换 <a class="header-anchor" href="#分支切换" aria-hidden="true">#</a></h3><p>首先需要了解下什么是分支切换</p><div class="language-js"><pre><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">ok</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;effect&#39;</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> obj<span class="token punctuation">.</span>ok <span class="token operator">?</span> obj<span class="token punctuation">.</span>text<span class="token operator">:</span> <span class="token string">&#39;not&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>副作用函数内部存在一个三元表达式，根据 obj.ok 值的不同会执行不同的代码分支。当 obj.ok 的值发生改变时，代码执行的分支就会发生改变，这就是所谓的分支切换。</p><h3 id="建立关联" tabindex="-1">建立关联 <a class="header-anchor" href="#建立关联" aria-hidden="true">#</a></h3><p>分支切换会产生遗留的副作用函数。执行上面的代码，obj.ok 为 true，此时就会触发 obj.ok 和 obj.text 这两个属性的读取操作，此时的副作用函数 effectFn 与响应式数据的关系如下</p><div class="language-"><pre><code>data
  └── ok
      └──  effectFn
  └── text
      └──  effectFn
</code></pre></div><p>当修改 obj.ok 的值为 false 时，会触发副作用函数重新执行，由于此时 obj.text 不会被读取，只会触发 obj.ok 的读取操作，所以理想情况下此时 effectFn 与响应式的数据如下</p><div class="language-"><pre><code>data
  └── ok
      └──  effectFn
</code></pre></div><p>很明显，按照之前写的，还实现不了这一点。</p><p>解决这个问题思路也很简单，我们每次执行副作用函数时，删除掉之前的依赖关系，重新建立依赖关系就可以了。</p><p>首先，要将一个副作用函数从所有与之关联的依赖集合中移除，就需要明确知道哪些依赖集合中是否包含它，所以需要副作用函数与依赖集合间建立联系</p><div class="language-js"><pre><code><span class="token keyword">let</span> activeEffect
<span class="token comment">// 将副作用函数添加一个 deps 数组，用来存储与该副作用函数相关的依赖集合</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        activeEffect <span class="token operator">=</span> effectFn
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 track 函数执行时，可以把当前依赖集合添加到当前副作用函数的 deps 数组中，这样联系就建立起来了</p><div class="language-diff"><pre><code>function track(target, key) {
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   if (!activeEffect) return
</span><span class="token prefix unchanged"> </span><span class="token line">   let depsMap = bucket.get(target)
</span><span class="token prefix unchanged"> </span><span class="token line">   if (!depsMap) {
</span><span class="token prefix unchanged"> </span><span class="token line">       bucket.set(target, (depsMap = new Map()))
</span><span class="token prefix unchanged"> </span><span class="token line">   }
</span><span class="token prefix unchanged"> </span><span class="token line">   let deps = depsMap.get(key)
</span><span class="token prefix unchanged"> </span><span class="token line">   if (!deps) {
</span><span class="token prefix unchanged"> </span><span class="token line">       depsMap.set(key, (deps = new Set()))
</span><span class="token prefix unchanged"> </span><span class="token line">   }
</span><span class="token prefix unchanged"> </span><span class="token line">   // 把当前激活的副作用函数添加到依赖集合 deps 中
</span><span class="token prefix unchanged"> </span><span class="token line">   deps.add(activeEffect)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // 将当前的依赖集合添加到 deps数组中
</span><span class="token prefix inserted">+</span><span class="token line">    activeEffect.deps.push(deps)
</span></span>}
</code></pre></div><h3 id="cleanup" tabindex="-1">cleanup <a class="header-anchor" href="#cleanup" aria-hidden="true">#</a></h3><p>建立联系后，每次执行副作用函数时， 根据副作用函数的 deps 数组中删除掉所有相关联的集合。</p><p>我们将清除工作放到 cleanup 函数中</p><div class="language-diff"><pre><code>let activeEffect
// 将副作用函数添加一个 deps 数组，用来存储与该副作用函数相关的依赖集合
function effect(fn) {
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   function effectFn() {
</span><span class="token prefix unchanged"> </span><span class="token line">       activeEffect = effectFn
</span><span class="token prefix unchanged"> </span><span class="token line">       // 清除工作
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        cleanup(activeEffect)
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       fn()
</span><span class="token prefix unchanged"> </span><span class="token line">   }
</span><span class="token prefix unchanged"> </span><span class="token line">   effectFn.deps = []
</span><span class="token prefix unchanged"> </span><span class="token line">   effectFn()
</span></span>}
</code></pre></div><p>下面是 cleanup 函数的实现</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token comment">// 把 effectFn 从依赖集合中删除</span>
        deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重置数组</span>
    effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后执行代码，我们会发现，会发现会导致无限循环，会出现下面报错信息</p><div class="language-"><pre><code>Uncaught RangeError: Maximum call stack size exceeded
</code></pre></div><p>出现的原因就在我们写的 trigger 函数中</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 问题出现在这里</span>
    deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们遍历 deps 集合，会执行下面几个步骤</p><ol><li>执行集合中存储的副作用函数 effectFn</li><li>副作用函数执行过程中，会调用 cleanup 清除相关依赖</li><li>然后在调用我们传入的副作用函数 fn</li><li>执行我们传入的副作用函数 fn 时，会导致重新被收集到依赖中</li></ol><p>实际上执行过程就跟下面的类似</p><div class="language-js"><pre><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
set<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;遍历中&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre></div><p>执行代码后，我们发现一直无限打印 &#39;遍历中&#39;</p><div class="tip custom-block"><p class="custom-block-title">语言规范说明</p><p>在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合中，如果此时遍历没有结束，那么该值会被重新访问</p></div><p>解决办法很简单，可以另外构造一个 Set 集合并遍历它</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span>
    effectsToRun <span class="token operator">&amp;&amp;</span> effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行过程中，依赖删除和增加是不会影响到 effectsToRun 的，所以就不会出现无限循环了</p><h2 id="嵌套的-effect-与-effect-栈" tabindex="-1">嵌套的 effect 与 effect 栈 <a class="header-anchor" href="#嵌套的-effect-与-effect-栈" aria-hidden="true">#</a></h2></div></div><footer class="page-footer" data-v-70cd7a5b data-v-7c1f404e><div class="edit" data-v-7c1f404e><div class="edit-link" data-v-7c1f404e data-v-760d8fa8><!----></div></div><div class="updated" data-v-7c1f404e><!----></div></footer><div class="next-and-prev-link" data-v-70cd7a5b data-v-e2088930><div class="container" data-v-e2088930><div class="prev" data-v-e2088930><a class="link" href="/vue-design/guide/design/thinking" data-v-e2088930><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-e2088930><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-e2088930>Vue.js 3 的设计思路</span></a></div><div class="next" data-v-e2088930><a class="link" href="/vue-design/guide/reactivity/non-original" data-v-e2088930><span class="text" data-v-e2088930>非原始值的响应式方案</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-e2088930><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"guide_design_art.md\":\"ce9329c2\",\"guide_design_elements.md\":\"19425969\",\"guide_design_thinking.md\":\"209cd0c7\",\"guide_reactivity_function-and-realization.md\":\"3dae69b3\",\"guide_reactivity_non-original.md\":\"08a4acf8\",\"guide_reactivity_original.md\":\"e11d1141\",\"index.md\":\"d570140d\"}")</script>
    <script type="module" async src="/vue-design/assets/app.43db1add.js"></script>
    
  </body>
</html>